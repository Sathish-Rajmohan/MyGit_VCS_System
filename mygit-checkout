#!/usr/bin/env python3

# mygit-checkout - Switches branches or restores working tree files
# Usage: mygit-checkout <branch_name>
# where <branch_name> is the name of the branch to switch to

import os
import sys
import shutil

def files_are_same(file1, file2):
    """Check if two files have the same content"""
    if not (os.path.exists(file1) and os.path.exists(file2)):
        return False
    try:
        with open(file1, 'rb') as f1, open(file2, 'rb') as f2:
            return f1.read() == f2.read()
    except:
        return False

def get_latest_commit_for_branch(branch_name):
    """Get the latest commit for a branch"""
    commit_count_file = '.mygit/commit_count'
    if not os.path.exists(commit_count_file):
        return None

    with open(commit_count_file, 'r') as f:
        commit_count = int(f.read().strip())

    # Check for commits explicitly associated with the branch
    for commit_num in range(commit_count - 1, -1, -1):
        branch_file = os.path.join('.mygit', 'objects', str(commit_num), '.branch')
        if os.path.exists(branch_file):
            with open(branch_file, 'r') as f:
                commit_branch = f.read().strip()
            if commit_branch == branch_name:
                return commit_num

    # If no commits are explicitly associated with this branch,
    # find where it was created by looking at branches snapshots
    branches_file = '.mygit/branches'
    if os.path.exists(branches_file):
        with open(branches_file, 'r') as f:
            branches = {line.strip() for line in f if line.strip()}
        if branch_name in branches:
            # Look through commits to find where this branch first appears
            # We need to find the commit from the branch that was current when this branch was created
            previous_branches = set(['trunk'])  # trunk always exists
            
            for commit_num in range(0, commit_count):
                # Check what branches existed at this commit
                branches_snapshot = os.path.join('.mygit', 'objects', str(commit_num), '.branches_snapshot')
                if os.path.exists(branches_snapshot):
                    with open(branches_snapshot, 'r') as f:
                        current_branches = {line.strip() for line in f if line.strip()}
                    
                    # If this is where our branch first appeared, this commit represents
                    # the state from which the branch was created
                    if branch_name in current_branches and branch_name not in previous_branches:
                        return commit_num
                    
                    previous_branches = current_branches
            
            # If we couldn't find it in snapshots, fallback to earliest commit
            for commit_num in range(0, commit_count):
                commit_dir = os.path.join('.mygit', 'objects', str(commit_num))
                if os.path.exists(commit_dir) and any(not f.startswith('.') for f in os.listdir(commit_dir)):
                    return commit_num

    return None

def main():
    if len(sys.argv) != 2:
        print(f"usage: {os.path.basename(sys.argv[0])} <branch>", file=sys.stderr)
        sys.exit(1)

    if not os.path.exists('.mygit'):
        print(f"{os.path.basename(sys.argv[0])}: error: no .mygit directory containing mygit repository exists", file=sys.stderr)
        sys.exit(1)

    branch_name = sys.argv[1]

    # Check if branch exists
    branches_file = '.mygit/branches'
    branches = set()
    if os.path.exists(branches_file):
        with open(branches_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line:
                    branches.add(line)

    if branch_name not in branches:
        print(f"{os.path.basename(sys.argv[0])}: error: unknown branch '{branch_name}'", file=sys.stderr)
        sys.exit(1)

    # Get current branch
    current_branch_file = '.mygit/current_branch'
    current_branch = 'trunk'
    if os.path.exists(current_branch_file):
        with open(current_branch_file, 'r') as f:
            current_branch = f.read().strip()

    if branch_name == current_branch:
        print(f"Already on '{branch_name}'")
        return

    # Find the latest commit for the target branch
    target_commit = get_latest_commit_for_branch(branch_name)
    if target_commit is None:
        print(f"{os.path.basename(sys.argv[0])}: error: no commits in repository", file=sys.stderr)
        sys.exit(1)

    # Get current files in working directory (excluding mygit scripts and hidden files)
    current_files = set()
    for item in os.listdir('.'):
        if os.path.isfile(item) and not item.startswith('.') and not item.startswith('mygit-'):
            current_files.add(item)

    # Get index files
    index_dir = '.mygit/index'
    index_files = set(os.listdir(index_dir)) if os.path.exists(index_dir) else set()

    # Get target commit files
    target_files = set()
    target_commit_dir = os.path.join('.mygit', 'objects', str(target_commit))
    for filename in os.listdir(target_commit_dir):
        if not filename.startswith('.'):
            target_files.add(filename)

    # Check for files that would be overwritten
    conflicting_files = []
    
    # Check tracked files for conflicts
    for filename in target_files:
        if filename in current_files:
            current_file = filename
            index_file = os.path.join(index_dir, filename) if filename in index_files else None
            target_file = os.path.join(target_commit_dir, filename)

            # Check if current file is different from both index and target
            current_same_as_index = files_are_same(current_file, index_file) if index_file and os.path.exists(index_file) else False
            current_same_as_target = files_are_same(current_file, target_file)

            # Only consider it a conflict if:
            # 1. The current file is different from the index (has local changes)
            # 2. The current file is different from the target (would be overwritten)
            # 3. The target file is also different from the index (target would change the file)
            if not current_same_as_index and not current_same_as_target:
                index_same_as_target = files_are_same(index_file, target_file) if index_file and os.path.exists(index_file) else False
                if not index_same_as_target:
                    if filename not in conflicting_files:  # Avoid duplicates
                        conflicting_files.append(filename)

    # Check for untracked files that would be overwritten
    for filename in current_files - index_files:  # untracked files
        if filename in target_files:  # would be overwritten by checkout
            if filename not in conflicting_files:  # Avoid duplicates
                conflicting_files.append(filename)

    if conflicting_files:
        print(f"{os.path.basename(sys.argv[0])}: error: Your changes to the following files would be overwritten by checkout:", file=sys.stderr)
        for filename in sorted(conflicting_files):
            print(filename, file=sys.stderr)
        sys.exit(1)

    # Remove files that are tracked but not in target
    for filename in current_files:
        if filename not in target_files and filename in index_files:
            if os.path.exists(filename):
                os.remove(filename)

    # Copy files from target commit to working directory, preserving local changes
    for filename in target_files:
        src = os.path.join(target_commit_dir, filename)
        if os.path.exists(src):
            if filename in current_files:
                index_file = os.path.join(index_dir, filename) if filename in index_files else None
                current_same_as_index = files_are_same(filename, index_file) if index_file and os.path.exists(index_file) else False
                if not current_same_as_index:
                    # Preserve working directory file if it has untracked or unstaged changes
                    continue
            shutil.copy2(src, filename)

    # Update index with files from target commit, preserving staged changes
    old_index_files = {}
    if os.path.exists(index_dir):
        for filename in os.listdir(index_dir):
            old_index_path = os.path.join(index_dir, filename)
            if os.path.exists(old_index_path):
                with open(old_index_path, 'rb') as f:
                    old_index_files[filename] = f.read()
            os.remove(old_index_path)
    else:
        os.makedirs(index_dir)

    for filename in target_files:
        src = os.path.join(target_commit_dir, filename)
        dst = os.path.join(index_dir, filename)
        
        # Preserve staged changes if they match the working directory and don't conflict with target
        should_preserve_staged = False
        if filename in old_index_files and filename in current_files:
            with open(src, 'rb') as f:
                target_content = f.read()
            old_index_content = old_index_files[filename]
            with open(filename, 'rb') as f:
                working_content = f.read()
            if old_index_content == working_content and old_index_content != target_content:
                should_preserve_staged = True
        
        if should_preserve_staged:
            with open(dst, 'wb') as f:
                f.write(old_index_files[filename])
        else:
            shutil.copy2(src, dst)

    # Update current branch
    with open(current_branch_file, 'w') as f:
        f.write(branch_name)

    print(f"Switched to branch '{branch_name}'")

if __name__ == '__main__':
    main()